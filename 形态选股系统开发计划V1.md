形态选股系统开发计划和指令V1
项目目标
开发一个基于 Python 的形态选股系统，使用 AKShare 获取中国 A 股数据，采用动态时间规整 (DTW) 和 K-Shape 算法进行股票形态匹配，并通过 Plotly Dash 框架构建交互式用户界面，最终实现类似同花顺软件的形态选股功能。系统仅支持均线技术指标，用户可选择标准形态并匹配全市场约 5000 只股票，按匹配度输出结果，并支持交互式 K 线图显示。

技术选型
前端框架： Plotly Dash (Python)

理由： 基于 Python，与后端和算法部分技术栈一致；Dash 专注于数据可视化，适合快速构建交互式 K 线图和用户界面；提供拖拽、缩放等交互功能，易于实现用户选择标准形态；与 Plotly 集成无缝，生成专业金融图表。
后端框架： Flask (Python)

理由： 轻量级、灵活，满足当前系统 API 需求；与 Dash 和 Python 生态兼容，易于集成算法和数据处理模块；用户确认 Flask 足够，适合中小型应用，确保 API 的可用性和稳定性。
数据获取： AKShare (Python)

理由： 提供全面的 A 股历史 K 线数据（OHLCV 和成交量），参考 AKShare 股票数据文档；Python 原生支持，易于集成；需注意 API 调用频率限制，建议缓存数据。
数据存储： SQLite

理由： 轻量级嵌入式数据库，适合存储历史股票数据；Python 内置 sqlite3 库，开发和维护简单；数据量适中（约 5000 只股票，每只 2500 天数据），每天更新，SQLite 性能足够；支持索引优化查询。
编程语言： Python

理由： 团队熟悉 Python；拥有丰富库支持（Dash、Flask、AKShare、Pandas、NumPy、SciPy、dtaidistance、tslearn）；生态成熟，适合金融数据处理和算法开发。
图表库： Plotly

理由： 与 Dash 框架无缝集成；提供交互式 K 线图（Candlestick）和成交量图，支持均线显示；可视化效果专业，适合金融应用。
算法库：

dtaidistance（DTW 算法）：dtaidistance 文档
tslearn（K-Shape 算法）：tslearn 文档
理由： dtaidistance 提供高效 DTW 实现，tslearn 支持 K-Shape 聚类，适合时间序列分析。
算法选择和参数
核心算法： 动态时间规整 (DTW) + K-Shape 聚类

DTW： 计算标准形态与待匹配股票 K 线（仅使用收盘价或均线数据）的相似度，处理时间序列偏移和长度不一致，适合股票形态匹配。
K-Shape： 作为预处理，用于初步聚类，减少 DTW 计算量，找到相似形态的股票群体。
预处理：

数据清洗： 处理 AKShare 数据的缺失值和异常值，确保数据质量。
特征提取： 仅使用均线数据（如 5 日、10 日、20 日均线）或收盘价序列（用户选择），满足"仅支持均线"的需求。
标准化/归一化： 对时间序列数据进行归一化（0-1 范围），消除价格尺度差异，提高算法准确性。
匹配度计算：

使用 DTW 算法计算距离，相似度公式为 similarity = 1 / (1 + DTW_distance)，值越接近 1 表示越相似。
定义匹配度阈值（如 0.85），过滤低匹配度结果，通过人工标注数据验证和用户反馈确定最终值。
性能优化：

使用 Python multiprocessing 实现并行计算，处理 5000 只股票的形态匹配。
可选 GPU 加速（如使用 CuPy 或 TensorFlow），如果性能测试发现瓶颈。
限制： 不支持用户自定义窗口大小，标准形态长度由用户拖拽选择固定，匹配时使用相同窗口。

系统架构
整体架构： 前后端分离的单体应用架构。
组件：
数据获取模块 (Data Fetcher)： 使用 AKShare API 获取股票数据，每日定时更新至 SQLite。
数据存储模块 (Data Storage)： SQLite 存储历史 K 线数据（股票代码、日期、OHLCV、成交量、均线）。
算法模块 (Algorithm Module)： 实现 DTW 和 K-Shape，执行形态匹配计算。
后端 API (Backend API)： Flask 提供 RESTful API，支持数据获取、形态保存和匹配计算。
前端 UI (Frontend UI)： Dash 构建交互式界面，展示 K 线图、形态选择和选股结果。
数据流：
数据获取模块从 AKShare 获取数据，存储至 SQLite。
后端 API 从 SQLite 读取数据，提供给算法模块计算。
算法模块返回匹配结果给后端 API。
前端 UI 通过 API 调用获取数据和结果，进行可视化和交互。
并行计算： 使用 multiprocessing 加速形态匹配，确保 5000 只股票的计算效率。

开发计划
阶段一：数据获取与存储 
任务 1.1： 调研 AKShare API，确定所需数据接口（股票历史 K 线数据）。

AI 指令（Cursor/Sonnet）： 分析 AKShare API 文档，重点研究 A 股历史数据获取。

具体任务：
1. 确认 ak.stock_zh_a_hist 函数是否为获取日 OHLCV 数据的最佳选择
2. 研究函数参数：symbol（股票代码）、period（周期，'daily'）、start_date、end_date、adjust（复权类型）
3. 验证返回数据结构，确保包含：日期、开盘价、最高价、最低价、收盘价、成交量
4. 测试 API 调用限制和频率限制，记录限制条件
5. 创建简单测试脚本，获取一支股票的历史数据并展示
6. 记录 API 可能的错误类型和处理方法
7. 评估每日更新数据的最佳策略

将分析结果记录在 data_api_research.md，包含示例代码、参数说明、返回格式和使用注意事项。
任务 1.2： 设计 SQLite 数据库 schema，存储股票代码、日期、OHLCV、成交量和均线数据。

AI 指令：   设计 SQLite 数据库架构，用于存储 A 股历史数据和计算指标。

具体任务：
1. 创建 stocks 表：
   - stock_code (TEXT, PRIMARY KEY)：股票代码，如 '600000'
   - stock_name (TEXT)：股票名称
   - listing_date (DATE)：上市日期
   - is_active (BOOLEAN)：是否活跃（未退市）

2. 创建 daily_data 表：
   - id (INTEGER PRIMARY KEY AUTOINCREMENT)
   - stock_code (TEXT)：股票代码，外键关联 stocks 表
   - trade_date (DATE)：交易日期
   - open (REAL)：开盘价
   - high (REAL)：最高价
   - low (REAL)：最低价
   - close (REAL)：收盘价
   - volume (REAL)：成交量
   - ma5 (REAL)：5日均线
   - ma10 (REAL)：10日均线
   - ma20 (REAL)：20日均线
   - 添加复合索引 (stock_code, trade_date)

3. 创建 pattern_templates 表（存储用户保存的标准形态）：
   - id (INTEGER PRIMARY KEY AUTOINCREMENT)
   - name (TEXT)：形态名称
   - data (TEXT)：JSON格式存储的形态数据
   - created_at (TIMESTAMP)：创建时间

将 SQL 创建语句写入 database_schema.sql 文件，包含表创建、索引创建和外键约束。为每个表添加详细注释说明字段用途。
任务 1.3： 编写 Python 脚本，使用 AKShare 获取数据，计算均线，存储至 SQLite，实现每日更新。

AI 指令：创建数据获取和存储模块，实现从 AKShare 获取股票数据并存入 SQLite 数据库。

具体任务：
1. 创建 data_fetcher.py 文件，包含以下功能：
   - 获取 A 股股票列表函数 get_stock_list()
   - 获取单只股票历史数据函数 get_stock_history(stock_code, start_date=None, end_date=None)
   - 计算技术指标函数 calculate_indicators(df)，计算 5、10、20 日均线
   - 数据存储函数 save_to_db(df, stock_code)
   - 增量更新函数 update_daily_data()，仅获取新数据
   - 完整初始化函数 initialize_database()，获取所有历史数据
   - 主函数 main()，支持命令行参数控制更新模式

2. 实现异常处理：
   - 网络错误重试机制（最多重试 3 次，间隔递增）
   - API 限流处理（检测到限流时等待）
   - 数据完整性验证（检查必要字段是否存在）

3. 实现日志记录：
   - 使用 Python logging 模块记录运行情况
   - 记录更新的股票数、新增数据条数、错误情况

4. 实现性能优化：
   - 批量插入数据（使用 executemany）
   - 使用事务提高写入性能
   - 适当设置 SQLite 缓存大小

5. 添加调度功能：
   - 创建 data_updater.py，实现每日自动更新
   - 使用系统调度工具（如 cron）或 Python 调度库（如 schedule）

确保代码包含详细注释，使用 try-except 处理可能的异常，并实现数据验证以确保数据质量。

阶段二：后端 API 开发 
任务 2.1： 搭建 Flask 框架，设计 RESTful API 接口。
AI 指令：搭建 Flask RESTful API 框架，为形态选股系统提供后端服务。

具体任务：
1. 创建项目结构：
/stock_pattern_api /app /init.py # Flask 应用初始化 /models.py # 数据库模型 /utils.py # 工具函数 /api /init.py /stocks.py # 股票数据 API /patterns.py # 形态模板 API /matching.py # 形态匹配 API /config.py # 配置文件 /run.py # 应用入口 /requirements.txt # 依赖列表

 2. 实现以下 RESTful API 端点：
- GET /api/v1/stocks：获取股票列表
- GET /api/v1/stocks/<stock_code>：获取单个股票基本信息
- GET /api/v1/stocks/<stock_code>/history：获取股票历史数据
  - 支持参数：start_date, end_date, indicator (选择技术指标，如 ma5, ma10, ma20)
- GET /api/v1/patterns：获取保存的形态模板列表
- GET /api/v1/patterns/<pattern_id>：获取特定形态模板详情
- POST /api/v1/patterns：保存新的形态模板
- PUT /api/v1/patterns/<pattern_id>：更新形态模板
- DELETE /api/v1/patterns/<pattern_id>：删除形态模板
- POST /api/v1/matching：执行形态匹配
  - 参数：pattern_data (标准形态数据), indicator (使用的指标), threshold (匹配阈值)

3. 使用 Flask-RESTful 扩展实现 API 资源：
- 创建资源类如 StockList, StockDetail, PatternList 等
- 实现适当的 HTTP 方法（get, post, put, delete）
- 使用 reqparse 或 marshmallow 进行请求参数验证

4. 实现错误处理和响应格式标准化：
- 定义统一的响应格式（包含状态码、消息和数据）
- 创建自定义错误类和错误处理器
- 处理常见错误（404 Not Found, 400 Bad Request 等）

5. 添加基本的安全措施：
- 实现请求限流（使用 Flask-Limiter）
- 添加 CORS 支持（使用 Flask-CORS）
- 考虑将来的认证需求（预留接口）

创建 app/__init__.py 和 run.py 文件，确保 API 服务可以正常启动。实现一个简单的健康检查端点 GET /api/v1/health。确保所有 API 端点返回 JSON 格式响应。
任务 2.2： 实现数据库访问层，提供数据查询和操作功能。

AI 指令：实现数据库访问层，为 API 提供数据操作功能。

具体任务：
1. 创建数据库连接管理：
   - 在 app/models.py 中实现数据库连接类 Database
   - 使用连接池管理 SQLite 连接
   - 实现事务支持和错误处理

2. 实现股票数据访问类 StockDAO：
   - 获取股票列表方法 get_stock_list(limit=None, offset=None)
   - 获取单只股票信息方法 get_stock_info(stock_code)
   - 获取股票历史数据方法 get_stock_history(stock_code, start_date=None, end_date=None, indicators=None)
   - 支持按日期范围和技术指标过滤
   - 确保查询性能（使用适当的索引和参数化查询）

3. 实现形态模板数据访问类 PatternDAO：
   - 获取形态列表方法 get_pattern_list()
   - 获取单个形态方法 get_pattern(pattern_id)
   - 保存形态方法 save_pattern(name, data)
   - 更新形态方法 update_pattern(pattern_id, name, data)
   - 删除形态方法 delete_pattern(pattern_id)
   - 使用 JSON 序列化/反序列化处理形态数据

4. 实现数据验证和异常处理：
   - 创建自定义异常类（如 DataNotFoundError, ValidationError）
   - 实现输入参数验证函数
   - 追加详细错误日志

5. 优化查询性能：
   - 对频繁查询实现内存缓存
   - 分析并优化查询语句
   - 针对大数据查询实现分页

确保所有数据访问方法包含详细注释，说明参数、返回值和可能的异常。实现单元测试验证数据访问层的正确性和性能。

任务 2.3： 实现算法模块调用接口，集成 DTW 和 K-Shape 算法。

AI 指令：实现算法调用接口，集成 DTW 和 K-Shape 算法到 API 中。

具体任务：
1. 创建算法服务类 AlgorithmService：
   - 在 app/services/algorithm_service.py 中实现
   - 依赖注入数据访问对象，便于测试和解耦

2. 实现 DTW 算法接口：
   - 引入 dtaidistance 库
   - 实现 compute_dtw_similarity(pattern_series, target_series, **kwargs) 方法
   - 支持参数配置（如 window_size, use_fastdtw 等）
   - 实现相似度归一化和结果排序

3. 实现 K-Shape 预处理接口：
   - 引入 tslearn 库
   - 实现 perform_kshape_clustering(series_list, n_clusters=10, **kwargs) 方法
   - 返回聚类结果和中心点
   - 添加聚类结果缓存以提高性能

4. 实现形态匹配服务方法：
   - 创建 match_pattern(pattern_data, indicator, threshold=0.85) 方法
   - 整合 K-Shape 预聚类和 DTW 精确匹配
   - 使用多进程并行计算（multiprocessing）
   - 按相似度降序排列返回结果

5. 添加性能监控和优化：
   - 记录算法执行时间和资源使用
   - 实现计算结果缓存
   - 提供计算状态查询接口（针对长时间运行的计算）

6. 实现算法参数调优功能：
   - 提供方法测试不同参数组合的效果
   - 记录和比较不同参数的性能表现

确保算法接口具有良好的错误处理机制，并在计算失败时提供有用的错误消息。添加详细注释说明算法原理和参数影响。实现单元测试验证算法接口的正确性。

任务 2.4： 编写单元测试和集成测试，验证 API 功能。

AI 指令：编写测试套件，确保 API 功能正确可靠。

具体任务：
1. 创建测试目录结构：
/tests /unit /models # 数据访问层测试 /services # 服务层测试 /api # API 端点测试 /integration # 集成测试 /fixtures # 测试数据和工具 conftest.py # Pytest 配置

2. 实现单元测试：
- 为 DAO 类编写测试（使用 mock 或测试数据库）
- 为算法服务类编写测试（模拟输入数据和预期输出）
- 为 API 资源类编写测试（使用 Flask 测试客户端）
- 使用 pytest 和 pytest-mock 框架

3. 实现集成测试：
- 测试完整 API 调用流程
- 验证数据库交互
- 测试实际算法计算结果
- 使用测试数据集（小型数据集以加快测试速度）

4. 创建测试数据和工具：
- 生成测试用的股票数据
- 创建已知模式的形态数据
- 实现测试辅助函数

5. 实现测试自动化：
- 编写测试运行脚本
- 配置测试覆盖率报告（使用 pytest-cov）
- 设置 CI 集成（可选）

6. 添加性能测试：
- 测试 API 响应时间
- 测试并发请求处理能力
- 测试算法计算性能

确保测试覆盖所有关键功能和边缘情况。实现测试前置和后置处理，确保测试环境的一致性。编写详细的测试文档，说明如何运行测试和解释测试结果。

阶段三：算法模块开发
任务 3.1： 实现 DTW 算法，计算时间序列相似度。

AI 指令：实现基于 DTW 的时间序列相似度计算模块。

具体任务：
1. 创建 algorithm/dtw_matcher.py 文件：
   - 实现 DTWMatcher 类，封装 DTW 算法功能
   - 使用 dtaidistance 库作为核心计算引擎
   - 设计灵活的接口，支持不同参数配置

2. 实现核心方法：
   - compute_distance(series1, series2, **kwargs)：计算两个时间序列的 DTW 距离
   - compute_similarity(series1, series2, **kwargs)：转换距离为相似度（0-1范围）
   - find_best_matches(pattern, candidates, top_n=10, threshold=0.85)：在候选集中找到最佳匹配
   - normalize_series(series)：归一化时间序列（0-1范围）

3. 添加高级功能：
   - 实现 FastDTW 支持（降低计算复杂度）
   - 添加窗口约束参数（限制对齐路径）
   - 支持多长度序列的比较（处理不等长序列）
   - 支持权重调整（强调特定部分的重要性）

4. 实现性能优化：
   - 使用 NumPy 向量化操作
   - 实现并行计算（多进程处理多个候选序列）
   - 添加计算结果缓存
   - 实现提前终止机制（当距离超过阈值时）

5. 添加可视化辅助功能：
   - plot_warping_path(series1, series2)：可视化 DTW 对齐路径
   - plot_similarity_matrix(pattern, matches)：热图显示相似度矩阵

6. 实现详细的错误处理和日志记录：
   - 验证输入数据有效性
   - 记录计算过程和异常情况
   - 提供性能统计信息

编写详细的类和方法文档，解释算法原理、参数影响和使用示例。实现单元测试验证算法在各种情况下的正确性和性能。

任务 3.2： 实现 K-Shape 算法，进行时间序列聚类预处理。

AI 指令：实现基于 K-Shape 的时间序列聚类预处理模块。

具体任务：
1. 创建 algorithm/kshape_clusterer.py 文件：
   - 实现 KShapeClusterer 类，封装 K-Shape 算法功能
   - 使用 tslearn 库的 KShape 实现
   - 设计灵活接口，支持参数调整

2. 实现核心方法：
   - fit(series_list, n_clusters=10, **kwargs)：对时间序列集合进行聚类
   - predict(new_series)：预测新序列所属的聚类
   - get_cluster_centers()：获取各聚类的中心序列
   - get_clusters()：获取聚类分组结果
   - preprocess_series(series)：预处理时间序列（规范化、缺失值处理等）

3. 添加高级功能：
   - 实现最佳聚类数自动确定（如肘方法）
   - 添加聚类质量评估指标（如轮廓系数）
   - 支持增量聚类（处理新数据）
   - 实现聚类结果可视化

4. 实现性能优化：
   - 使用并行计算加速聚类过程
   - 添加聚类结果缓存
   - 优化内存使用（处理大量时间序列）
   - 实现提前停止条件（收敛条件调整）

5. 添加辅助功能：
   - 聚类结果保存和加载
   - 聚类模型参数调优
   - 异常检测（识别不属于任何聚类的序列）

6. 实现详细的错误处理和日志记录：
   - 验证输入数据有效性
   - 处理聚类失败的情况
   - 记录聚类过程和性能统计

编写详细的类和方法文档，解释算法原理、参数影响和使用示例。实现单元测试验证算法在各种情况下的正确性和性能。
任务 3.3： 整合 DTW 和 K-Shape 算法，实现高效形态匹配功能。

AI 指令：整合 DTW 和 K-Shape 算法，实现高效的股票形态匹配功能。

具体任务：
1. 创建 algorithm/pattern_matcher.py 文件：
   - 实现 PatternMatcher 类，整合 DTW 和 K-Shape 功能
   - 使用组合模式，依赖注入 DTWMatcher 和 KShapeClusterer
   - 设计易用 API，隐藏底层复杂性

2. 实现核心方法：
   - initialize(stock_data)：初始化匹配器，预处理数据
   - preprocess_data(stock_data)：提取并标准化时间序列数据
   - cluster_stocks(n_clusters=20)：使用 K-Shape 对股票进行预聚类
   - find_matches(pattern, top_n=20, threshold=0.85)：查找与给定形态匹配的股票
   - compute_all_similarities(pattern)：计算与所有股票的相似度（用于调试）
   - get_match_details(stock_code, pattern)：获取特定匹配的详细信息

3. 实现两阶段匹配策略：
   - 第一阶段：使用 K-Shape 将股票分组，找到潜在匹配的聚类
   - 第二阶段：在选定聚类内使用 DTW 精确计算相似度
   - 实现阈值控制，平衡准确率和召回率

4. 添加高级功能：
   - 支持多指标匹配（如同时考虑 MA5、MA10、MA20）
   - 实现权重调整（不同指标的重要性）
   - 添加时间窗口控制（关注最近 N 天）
   - 支持形态变种识别（缩放和时间拉伸）

5. 实现性能优化：
   - 多进程并行计算（使用 ProcessPoolExecutor）
   - 分批处理大数据集
   - 实现计算结果缓存
   - 自适应计算策略（根据数据量调整算法参数）

6. 添加辅助功能：
   - 生成匹配报告（包含相似度、图表等）
   - 导出匹配结果（CSV、JSON 格式）
   - 匹配历史记录和比较

确保代码包含详细注释，并实现全面的错误处理。创建示例脚本演示如何使用匹配器。编写单元测试和集成测试验证匹配功能的准确性和性能。
任务 3.4： 实现算法性能优化，支持大规模数据的高效处理。

AI 指令：优化算法性能，使系统能够高效处理 A 股全市场约 5000 只股票的形态匹配。

具体任务：
1. 创建 algorithm/performance.py 文件：
   - 实现性能监控和优化功能
   - 提供性能测试和基准测试工具
   - 设计可配置的优化策略

2. 实现并行计算框架：
   - 使用 multiprocessing 模块创建工作进程池
   - 实现任务分割和结果合并功能
   - 优化进程间通信和数据共享
   - 添加进程管理（错误处理、超时控制）

3. 实现数据优化策略：
   - 数据预处理和缓存
   - 稀疏表示和压缩存储
   - 增量计算（仅处理新数据）
   - 数据分区和索引优化

4. 实现算法优化：
   - 早停策略（当距离超过阈值时停止计算）
   - 粗粒度到细粒度的多级匹配
   - 算法参数自动调优
   - 利用向量化操作（NumPy）

5. 添加内存优化：
   - 实现内存使用监控
   - 大型数据集的分块处理
   - 实现内存映射文件存储
   - 垃圾回收策略优化

6. 实现性能分析工具：
   - 计时装饰器和性能日志
   - 算法瓶颈识别
   - 资源使用监控（CPU、内存）
   - 性能报告生成

7. 考虑 GPU 加速（可选）：
   - 评估 GPU 加速可行性
   - 实现 CuPy 版本的核心算法
   - 比较 CPU 和 GPU 性能

进行基准测试，确保系统能在合理时间内（如 30 秒内）完成全市场股票的形态匹配。记录优化前后的性能对比，量化改进效果。编写性能调优指南，说明如何根据不同硬件配置调整参数。

任务 3.5： 实现算法可视化功能，展示形态匹配结果和过程。

AI 指令： 实现算法可视化模块，直观展示形态匹配结果和过程。

具体任务：
1. 创建 algorithm/visualization.py 文件：
   - 实现可视化功能类 MatchingVisualizer
   - 使用 Plotly 作为核心可视化库
   - 设计统一的可视化接口

2. 实现匹配结果可视化：
   - plot_matches(pattern, matches)：展示标准形态和匹配结果
   - plot_similarity_heatmap(similarities)：热图展示相似度分布
   - plot_match_comparison(pattern, match, warping_path)：对比显示并标注关键点
   - plot_match_distribution(matches)：展示相似度分布直方图

3. 实现算法过程可视化：
   - plot_dtw_matrix(series1, series2)：显示 DTW 计算矩阵
   - plot_warping_path(series1, series2, path)：展示时间规整路径
   - plot_kshape_clusters(clusters)：展示 K-Shape 聚类结果
   - plot_cluster_centers(centers)：展示聚类中心形态

4. 添加交互式可视化：
   - 支持缩放和平移
   - 添加工具提示显示详细数据
   - 实现高亮对比功能
   - 支持导出高质量图表

5. 实现性能可视化：
   - plot_performance_metrics(metrics)：展示算法性能指标
   - plot_computation_time(times)：展示计算时间分布
   - plot_resource_usage(usage)：展示资源使用情况

6. 添加批量可视化功能：
   - generate_match_report(pattern, matches)：生成完整匹配报告
   - export_visualizations(pattern, matches, format='html')：导出可视化结果

确保所有可视化功能支持自定义样式和布局。添加颜色方案，使图表专业美观。实现响应式设计，适应不同屏幕尺寸。编写详细文档，说明如何使用和自定义可视化功能。
任务 3.6： 编写算法模块单元测试和集成测试。

AI 指令： 为算法模块编写全面的测试套件，确保功能正确可靠。

具体任务：
1. 创建测试目录结构：
/tests/algorithm /unit test_dtw_matcher.py test_kshape_clusterer.py test_pattern_matcher.py test_performance.py test_visualization.py /integration test_end_to_end.py /fixtures sample_data.py known_patterns.py
2. 实现 DTW 算法单元测试：
- 测试基本距离计算
- 测试相似度转换
- 测试归一化功能
- 测试边缘情况（空序列、单点序列等）
- 测试不同参数配置
- 测试性能优化功能

3. 实现 K-Shape 算法单元测试：
- 测试聚类功能
- 测试预测功能
- 测试聚类中心提取
- 测试预处理功能
- 测试增量聚类
- 测试异常处理

4. 实现模式匹配器单元测试：
- 测试两阶段匹配策略
- 测试相似度计算
- 测试阈值过滤
- 测试多指标匹配
- 测试并行计算
- 测试缓存机制

5. 实现集成测试：
- 测试完整匹配流程
- 测试实际股票数据匹配
- 测试性能基准
- 测试内存使用情况
- 测试与数据库交互

6. 创建测试工具和辅助功能：
- 生成合成测试数据
- 创建已知形态和预期匹配
- 实现结果验证函数
- 添加性能测试装饰器

7. 实现可视化测试：
- 测试图表生成功能
- 验证可视化元素存在性
- 检查交互功能

使用 pytest 框架实现测试，确保测试覆盖率达到 80% 以上。编写详细的测试文档，说明如何运行测试和解释测试结果。实现持续集成，确保代码变更不会破坏现有功能。

阶段四：前端 UI 开发 
任务 4.1： 搭建 Plotly Dash 框架，创建基础页面布局。

AI 指令：搭建 Plotly Dash 框架，创建形态选股系统的基础页面布局。

具体任务：
1. 创建项目结构：
/stock_pattern_ui /assets # 静态资源（CSS、图片等） /components # UI 组件 /layouts # 页面布局 /callbacks # 交互回调 /utils # 工具函数 app.py # 主应用文件 index.py # 路由和页面组织 config.py # 配置文件
2. 设计主页面布局：
- 创建 layouts/main_layout.py
- 实现响应式布局，适应不同屏幕尺寸
- 设计清晰的导航结构
- 划分功能区域（形态选择区、结果展示区、详情查看区）
- 添加页眉和页脚

3. 实现基础 UI 组件：
- 创建 components/header.py：实现标题栏和导航菜单
- 创建 components/footer.py：实现页脚信息
- 创建 components/sidebar.py：实现侧边栏（参数控制和过滤器）
- 创建 components/loading.py：实现加载动画

4. 设置应用主题和样式：
- 创建 assets/style.css：定义全局样式
- 使用 Bootstrap 或自定义网格系统
- 定义一致的颜色方案和字体
- 确保界面专业美观，适合金融应用

5. 实现路由和多页面结构：
- 设置主页、形态选择页、结果页和帮助页
- 实现页面间导航
- 保持 URL 与页面状态同步

6. 添加响应式设计：
- 桌面和移动设备自适应布局
- 断点设置和组件重排
- 触摸友好的交互元素

7. 实现基础配置功能：
- 创建 config.py 管理 API 端点和环境设置
- 添加开发/生产环境切换
- 实现错误处理和日志记录

创建 app.py 和 index.py，确保应用可以启动并显示基础布局。实现简单的健康检查页面，验证与后端 API 的连接。确保所有页面元素具有合理的 ID，便于后续添加回调函数。
任务 4.2： 实现 K 线图和技术指标可视化组件。

AI 指令：  实现交互式 K 线图和技术指标可视化组件。

具体任务：
1. 创建 components/stock_chart.py 文件：
   - 实现 StockChart 组件类
   - 使用 Plotly 的 Candlestick 图表
   - 支持显示 OHLCV 数据
   - 添加均线显示（MA5、MA10、MA20）
   - 实现成交量子图

2. 添加交互功能：
   - 缩放和平移控制
   - 时间范围选择器
   - 十字光标和数据提示
   - 图表保存和导出

3. 实现图表配置选项：
   - 指标选择（切换不同均线）
   - 样式定制（颜色、线宽、透明度等）
   - 时间粒度调整（日、周、月）
   - 图表尺寸和比例控制

4. 添加形态选择功能：
   - 实现区域选择工具（用于标记形态）
   - 显示选中区域的高亮效果
   - 提取选中区域的时间序列数据
   - 保存和加载选中的形态

5. 实现多图表视图：
   - 主图显示价格和均线
   - 副图显示成交量
   - 可选择添加其他指标图
   - 实现图表联动（同步缩放和平移）

6. 添加专业金融图表特性：
   - 交易日正确处理（跳过非交易日）
   - 价格标签格式化（保留小数位）
   - 成交量单位显示（万、亿）
   - 重要日期标记（如除权除息日）

7. 优化性能：
   - 数据降采样（显示大量数据时）
   - 惰性加载（按需加载历史数据）
   - 渲染优化（减少重绘次数）

确保图表组件具有清晰的 API 和文档，便于集成和复用。实现图表主题切换功能（明/暗模式）。添加适当的图例和标签，增强可读性。确保组件在不同浏览器中表现一致。
任务 4.3： 实现形态选择和保存功能。

AI 指令：  实现用户选择和保存标准形态的功能。

具体任务：
1. 创建 components/pattern_selector.py 文件：
   - 实现 PatternSelector 组件类
   - 提供形态选择界面和工具
   - 设计直观的用户交互流程

2. 实现形态选择方式：
   - 从 K 线图上直接选择（区域选择工具）
   - 从预设形态库中选择
   - 从历史保存的形态中选择
   - 上传自定义形态数据

3. 添加形态编辑功能：
   - 调整选择范围（开始和结束日期）
   - 选择使用的技术指标（收盘价、MA5、MA10、MA20）
   - 添加形态名称和描述
   - 标记关键点或区域

4. 实现形态预览：
   - 显示选中形态的图表预览
   - 展示形态的关键特征
   - 提供形态统计数据（长度、波动范围等）
   - 支持形态缩放和调整

5. 添加形态保存功能：
   - 创建保存对话框组件
   - 输入形态名称和描述
   - 选择保存选项（私有/公共）
   - 将形态数据发送到后端 API

6. 实现形态管理：
   - 查看已保存形态列表
   - 编辑现有形态
   - 删除不需要的形态
   - 形态分类和标签

7. 添加形态共享功能（可选）：
   - 导出形态数据（JSON 格式）
   - 导入形态数据
   - 形态库浏览和搜索

确保用户界面简洁直观，操作流程符合用户习惯。添加适当的提示和帮助信息，指导用户完成形态选择。实现表单验证，防止无效数据提交。添加操作反馈，确认保存成功或提示错误。
任务 4.4： 实现形态匹配结果展示功能。

AI 指令：  实现形态匹配结果展示功能，直观显示匹配股票和相似度。

具体任务：
1. 创建 components/match_results.py 文件：
   - 实现 MatchResults 组件类
   - 设计结果展示界面
   - 提供多种查看方式（表格、卡片、图表等）

2. 实现匹配结果表格：
   - 显示匹配股票列表（股票代码、名称、相似度）
   - 支持排序（按相似度、股票代码等）
   - 添加分页功能（处理大量结果）
   - 实现表格过滤和搜索

3. 添加详细信息展示：
   - 点击股票显示详细匹配信息
   - 展示匹配图表对比（标准形态 vs 股票形态）
   - 显示相似度计算细节
   - 提供股票基本信息

4. 实现结果可视化：
   - 相似度分布直方图
   - 匹配度热图
   - 多股票形态对比图
   - 聚类结果可视化

5. 添加结果筛选功能：
   - 相似度阈值调整
   - 行业和板块过滤
   - 交易量和市值范围过滤
   - 自定义过滤条件

6. 实现结果导出功能：
   - 导出为 CSV/Excel
   - 导出匹配报告（PDF）
   - 保存匹配结果快照
   - 分享结果链接

7. 添加批量操作：
   - 选择多只股票进行比较
   - 批量添加到观察列表
   - 批量导出详细信息

确保界面响应迅速，即使处理大量结果也不卡顿。实现渐进式加载和虚拟滚动优化性能。添加适当的加载状态指示器。确保数据呈现清晰易读，使用合适的颜色和视觉编码表示相似度。
任务 4.5： 实现用户交互回调和数据流。

AI 指令：  实现 Dash 回调函数，处理用户交互和数据流。

具体任务：
1. 创建 callbacks/pattern_callbacks.py 文件：
   - 实现与形态选择相关的回调
   - 处理用户选择和表单提交
   - 连接 UI 组件与后端 API

2. 实现形态选择回调：
   - 处理图表区域选择事件
   - 更新形态预览
   - 提取选中区域的时间序列数据
   - 保存用户选择的形态

3. 实现匹配计算回调：
   - 发送形态数据到后端 API
   - 处理匹配计算请求
   - 更新匹配结果组件
   - 显示加载状态和进度

4. 实现股票数据加载回调：
   - 获取股票历史数据
   - 更新 K 线图
   - 处理日期范围变化
   - 实现数据缓存优化

5. 实现结果交互回调：
   - 处理结果排序和过滤
   - 更新详细信息视图
   - 处理导出请求
   - 响应用户选择操作

6. 添加全局状态管理：
   - 创建 utils/state.py 管理应用状态
   - 实现会话存储（保存用户选择）
   - 处理页面刷新和导航
   - 优化回调依赖关系

7. 实现错误处理和反馈：
   - 捕获 API 错误并显示友好信息
   - 添加操作成功通知
   - 实现输入验证和反馈
   - 记录客户端错误日志

确保回调函数高效无阻塞，避免UI卡顿。优化回调依赖链，减少不必要的触发。使用 Dash 的 clientside_callback 适当减轻服务器负担。实现防抖动和节流，避免频繁 API 调用。添加适当的异常处理，确保单个错误不会导致整个应用崩溃。
任务 4.6： 实现 API 服务连接和数据获取功能。

AI 指令：
实现前端与后端 API 的连接和数据获取功能。

具体任务：
1. 创建 utils/api_client.py 文件：
   - 实现 APIClient 类封装 API 调用
   - 使用 requests 库进行 HTTP 请求
   - 设计统一的错误处理和重试机制
   - 添加请求/响应日志记录

2. 实现股票数据 API：
   - get_stock_list()：获取股票列表
   - get_stock_info(stock_code)：获取股票基本信息
   - get_stock_history(stock_code, start_date, end_date, indicators)：获取历史数据
   - 实现数据缓存，减少重复请求

3. 实现形态管理 API：
   - get_patterns()：获取保存的形态列表
   - get_pattern(pattern_id)：获取形态详情
   - save_pattern(name, data)：保存新形态
   - update_pattern(pattern_id, name, data)：更新形态
   - delete_pattern(pattern_id)：删除形态

4. 实现匹配计算 API：
   - match_pattern(pattern_data, indicator, threshold)：执行形态匹配
   - get_match_status(job_id)：获取匹配计算状态（长时间计算）
   - get_match_results(job_id)：获取匹配结果
   - cancel_matching(job_id)：取消进行中的匹配计算

5. 添加认证和会话管理（可选）：
   - 实现登录/注销功能
   - 管理认证令牌
   - 处理会话过期
   - 添加用户偏好存储

6. 实现请求优化：
   - 批量请求（减少 HTTP 请求数量）
   - 请求队列和优先级
   - 并发请求（使用 asyncio 或线程池）
   - 自适应超时和重试策略

7. 添加离线模式支持（可选）：
   - 检测网络状态
   - 缓存必要数据
   - 队列化离线操作
   - 网络恢复时同步

确保所有 API 调用包含适当的错误处理和用户反馈。实现请求状态跟踪，显示加载指示器。处理网络延迟和服务器错误，提供友好的错误消息。添加请求取消功能，允许用户中断长时间操作。
任务 4.7： 进行用户界面测试和优化。

AI 指令：  测试和优化用户界面，确保良好的用户体验。

具体任务：
1. 创建 tests/ui 目录：
   - 实现用户界面测试套件
   - 设置测试环境和工具
   - 定义测试案例和断言

2. 实现组件单元测试：
   - 使用 pytest 和 dash.testing 测试框架
   - 测试各组件的渲染和行为
   - 验证组件属性和回调
   - 测试边缘情况和错误处理

3. 实现端到端测试：
   - 使用 Selenium 或 Playwright 测试完整用户流程
   - 验证页面导航和状态保持
   - 测试表单提交和数据显示
   - 检查响应式设计在不同屏幕尺寸下的表现

4. 进行性能优化：
   - 测量和改进页面加载时间
   - 优化大数据集的渲染性能
   - 减少不必要的重新渲染
   - 优化网络请求和缓存策略

5. 实施用户体验改进：
   - 添加键盘快捷键
   - 优化表单和控件布局
   - 改进错误和成功消息
   - 添加工具提示和帮助信息

6. 进行浏览器兼容性测试：
   - 验证在主流浏览器中的表现（Chrome, Firefox, Safari, Edge）
   - 解决浏览器特定的问题
   - 测试不同操作系统平台

7. 实现可访问性优化：
   - 添加 ARIA 标签和角色
   - 确保键盘导航支持
   - 验证颜色对比度
   - 测试屏幕阅读器兼容性

记录测试结果和发现的问题，按优先级排序进行修复。创建性能基准，确保优化有明确的度量标准。收集用户反馈，持续改进界面设计和交互体验。实现 A/B 测试，对比不同设计方案的效果。
阶段五：集成和测试 (预计 1 周)
任务 5.1： 集成前后端和算法模块，确保系统各部分协同工作。

AI 指令：  集成前后端和算法模块，确保系统各部分协同工作。

具体任务：
1. 创建集成测试环境：
   - 设置测试服务器和数据库
   - 配置前后端连接
   - 准备测试数据集
   - 定义集成测试计划

2. 实现端到端测试：
   - 测试完整数据流（从数据获取到结果显示）
   - 验证 API 调用和响应处理
   - 测试错误情况和边缘情况
   - 监控系统资源使用

3. 解决集成问题：
   - 修复数据格式不匹配
   - 协调 API 版本和接口定义
   - 解决跨模块依赖问题
   - 统一错误处理和日志记录

4. 实现系统配置管理：
   - 创建配置文件模板
   - 实现环境变量支持
   - 添加配置验证和默认值
   - 文档化配置选项

5. 设置部署管道：
   - 创建部署脚本
   - 配置容器化（可选，使用 Docker）
   - 实现自动化部署流程
   - 添加回滚机制

6. 进行性能测试：
   - 测量端到端响应时间
   - 评估系统在不同负载下的表现
   - 识别性能瓶颈
   - 实现性能监控

7. 创建系统文档：
   - 描述系统架构和组件
   - 记录 API 接口和数据格式
   - 编写部署和配置指南
   - 提供故障排除和常见问题解决方案

确保所有模块在集成环境中正常工作。实现健康检查接口，监控系统状态。创建系统启动和关闭流程。测试系统在异常情况下的恢复能力。
任务 5.2： 进行系统测试，验证功能需求和性能要求。

AI 指令：  进行全面的系统测试，验证所有功能需求和性能要求。

具体任务：
1. 创建测试计划：
   - 定义测试范围和目标
   - 制定测试策略和方法
   - 设计测试案例和场景
   - 准备测试数据和环境

2. 执行功能测试：
   - 验证所有用户故事和功能需求
   - 测试正常流程和异常流程
   - 检查数据完整性和一致性
   - 验证所有界面元素和交互

3. 进行性能测试：
   - 测量全市场形态匹配的响应时间
   - 评估同时处理多个用户请求的能力
   - 测试大数据集的处理性能
   - 监控资源使用（CPU、内存、磁盘）

4. 实施安全测试（基础级别）：
   - 检查基本输入验证
   - 测试访问控制（如果适用）
   - 验证数据保护措施
   - 检查敏感信息处理

5. 进行用户验收测试：
   - 邀请实际用户参与测试
   - 收集用户反馈和建议
   - 评估用户体验和满意度
   - 识别改进机会

6. 实施回归测试：
   - 确保修复和改进不破坏现有功能
   - 自动化关键测试案例
   - 建立持续测试流程
   - 维护测试覆盖率

7. 记录和跟踪问题：
   - 使用问题跟踪系统记录发现的缺陷
   - 按严重性和优先级分类问题
   - 跟踪问题解决进度
   - 验证问题修复效果

编写详细的测试报告，包括测试结果、发现的问题和建议改进。确保系统满足所有关键需求和性能目标。创建演示脚本，展示系统的核心功能和优势。
任务 5.3： 优化系统性能和用户体验，解决发现的问题。

AI 指令：  优化系统性能和用户体验，解决测试中发现的问题。

具体任务：
1. 性能优化：
   - 分析性能测试结果，识别瓶颈
   - 优化数据库查询和索引
   - 改进算法实现，减少计算时间
   - 优化前端渲染和数据加载
   - 实现适当的缓存策略

2. 用户体验改进：
   - 根据用户反馈优化界面布局
   - 改进交互流程，减少操作步骤
   - 添加进度指示和状态反馈
   - 优化错误消息和帮助信息
   - 完善响应式设计，适应不同设备

3. 修复已发现的问题：
   - 解决高优先级缺陷
   - 修复数据处理和显示错误
   - 解决浏览器兼容性问题
   - 修复 API 调用和响应处理问题
   - 解决边缘情况和异常处理

4. 代码质量改进：
   - 重构重复或复杂的代码
   - 移除未使用的代码和依赖
   - 统一编码风格和命名规范
   - 添加或改进代码注释
   - 优化模块结构和依赖关系

5. 资源优化：
   - 减少内存使用和泄漏
   - 优化网络请求数量和大小
   - 压缩和优化静态资源
   - 实现资源懒加载和按需加载
   - 优化服务器资源使用

6. 系统可靠性提升：
   - 增强错误恢复机制
   - 改进异常处理和日志记录
   - 添加系统监控和告警
   - 实现关键数据备份
   - 增强系统稳定性

7. 文档更新：
   - 更新用户指南和帮助文档
   - 记录优化措施和效果
   - 更新API文档和接口说明
   - 补充已知问题和解决方案

对每项优化进行测量和验证，确保改进有实际效果。记录性能基准和改进百分比。收集优化后的用户反馈，确保体验得到提升。创建优化报告，总结改进措施和成果。
任务 5.4： 准备系统在 Windows 11 本地计算机上的安装和运行方案。

具体任务：
1. 创建本地安装文档：
   - 系统组件和依赖关系说明
   - Windows 11 环境要求（Python 版本、必要软件）
   - 依赖项列表和版本要求
   - 安装和配置步骤
   - 启动和关闭程序

2. 准备安装脚本：
   - 创建自动化安装脚本 (setup.bat)
   - 编写数据库初始化脚本
   - 实现配置文件生成工具
   - 添加环境检查和验证
   - 编写数据备份脚本

3. 本地环境配置：
   - 配置本地 Python 环境
   - 设置 SQLite 数据库
   - 配置本地开发服务器
   - 实现环境变量管理
   - 建立开发/生产模式切换

4. 创建启动和管理工具：
   - 开发系统启动脚本 (start.bat)
   - 实现数据更新工具
   - 创建日志查看工具
   - 添加系统状态监控
   - 开发简单的管理界面

5. 准备用户文档：
   - 系统安装指南
   - 用户操作手册
   - 常见问题解答
   - 故障排除指南
   - 功能说明和教程

使用 requirements.txt 文件一键安装所有依赖
提供一键安装脚本 (setup.bat)
自动创建必要的文件夹结构
包含示例数据进行初始测试
启动优化：

总结
本文档提供了形态选股系统的完整开发计划和优化后的 AI 指令，专为 Cursor+Sonnet 工具实现而设计。系统采用 Python 技术栈，使用 AKShare 获取 A 股数据，应用 DTW 和 K-Shape 算法进行形态匹配，并通过 Plotly Dash 构建交互式用户界面。开发计划分为五个阶段：数据获取与存储、后端 API 开发、算法模块开发、前端 UI 开发以及集成和测试，每个阶段包含详细任务和 AI 指令，确保 Cursor 能够精准实现各项功能。系统设计为在单台 Windows 11 个人电脑上运行，无需服务器部署，简化了安装和维护流程，同时提供了本地环境优化建议以确保良好的性能和用户体验。